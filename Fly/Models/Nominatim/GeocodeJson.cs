// This file has been generated by https://app.quicktype.io/ , 
// according to the specifications at https://github.com/geocoders/geocodejson-spec/blob/master/draft/geocodejson.schema.json
// Classes in this file represent the output format of Nominatim's "Reverse" API in "geocodejson" format.
// See: https://nominatim.org/release-docs/latest/api/Output/#geocodejson

using System.Collections.Generic;

namespace Fly.Models.Nominatim;


/// <summary>
/// GeocodeJSON is an extension of the GeoJSON format and it is an attempt to create a
/// standard for handling geocoding results.
///
/// GeocodeJSON extension of GeoJSON Feature Collection
///
/// GeocodeJSON extension of GeoJSON Feature
/// </summary>
public partial class Coordinate
{
    public double[] Bbox { get; set; }
    public CoordinateCoordinate[] Coordinates { get; set; }

    /// <summary>
    /// REQUIRED. GeocodeJSON result is a FeatureCollection.
    /// </summary>
    public CoordinateType Type { get; set; }

    public CoordinateGeometry[] Geometries { get; set; }
    public GeoJson Geometry { get; set; }
    public Id? Id { get; set; }
    public Dictionary<string, object> Properties { get; set; }

    /// <summary>
    /// REQUIRED. As per GeoJSON spec.
    /// </summary>
    public Feature[] Features { get; set; }

    /// <summary>
    /// REQUIRED. Namespace.
    /// </summary>
    public CoordinateGeocoding Geocoding { get; set; }
}

/// <summary>
/// OPTIONAL. An array of feature objects.
/// </summary>
public partial class Feature
{
    /// <summary>
    /// REQUIRED. As per GeoJSON spec.
    /// </summary>
    public Properties Properties { get; set; }

    /// <summary>
    /// REQUIRED. As per GeoJSON spec.
    /// </summary>
    public FeatureType? Type { get; set; }
}

/// <summary>
/// REQUIRED. As per GeoJSON spec.
/// </summary>
public partial class Properties
{
    /// <summary>
    /// REQUIRED. Namespace.
    /// </summary>
    public PropertiesGeocoding Geocoding { get; set; }
}

/// <summary>
/// REQUIRED. Namespace.
/// </summary>
public partial class PropertiesGeocoding
{
    /// <summary>
    /// OPTIONAL. Result accuracy, in meters.
    /// </summary>
    public double? Accuracy { get; set; }

    /// <summary>
    /// OPTIONAL. Administratives boundaries the feature is included in, as defined in
    /// http://wiki.osm.org/wiki/Key:admin_level#admin_level.
    /// </summary>
    public Dictionary<string, object> Admin { get; set; }

    /// <summary>
    /// OPTIONAL. City of the place.
    /// </summary>
    public string City { get; set; }

    /// <summary>
    /// OPTIONAL. Country of the place.
    /// </summary>
    public string Country { get; set; }

    /// <summary>
    /// OPTIONAL. County of the place.
    /// </summary>
    public string County { get; set; }

    /// <summary>
    /// OPTIONAL. District of the place.
    /// </summary>
    public string District { get; set; }

    /// <summary>
    /// OPTIONAL. Geohash encoding of coordinates (see http://geohash.org/site/tips.html).
    /// </summary>
    public string Geohash { get; set; }

    /// <summary>
    /// OPTIONAL. Housenumber of the place.
    /// </summary>
    public string Housenumber { get; set; }

    /// <summary>
    /// RECOMMENDED. Suggested label for the result.
    /// </summary>
    public string Label { get; set; }

    /// <summary>
    /// OPTIONAL. Locality of the place.
    /// </summary>
    public string Locality { get; set; }

    /// <summary>
    /// OPTIONAL. Name of the place.
    /// </summary>
    public string Name { get; set; }

    /// <summary>
    /// OPTIONAL. Postcode of the place.
    /// </summary>
    public string Postcode { get; set; }

    /// <summary>
    /// OPTIONAL. State of the place.
    /// </summary>
    public string State { get; set; }

    /// <summary>
    /// OPTIONAL. Street of the place.
    /// </summary>
    public string Street { get; set; }

    /// <summary>
    /// REQUIRED. One of house, street, locality, city, region, country.
    /// </summary>
    public string Type { get; set; }
}

/// <summary>
/// REQUIRED. Namespace.
/// </summary>
public partial class CoordinateGeocoding
{
    /// <summary>
    /// OPTIONAL. The attribution of the data. In case of multiple sources, and then multiple
    /// attributions, can be an object with one key by source.
    /// </summary>
    public string Attribution { get; set; }

    /// <summary>
    /// OPTIONAL. The licence of the data. In case of multiple sources, and then multiple
    /// licences, can be an object with one key by source.
    /// </summary>
    public string Licence { get; set; }

    /// <summary>
    /// OPTIONAL. The query that has been issued to trigger the search.
    /// </summary>
    public string Query { get; set; }

    /// <summary>
    /// A semver.org compliant version number. Describes the version of the GeocodeJSON spec that
    /// is implemented by this instance.
    /// </summary>
    public string Version { get; set; }
}

public partial class CoordinateGeometry
{
    public double[] Bbox { get; set; }
    public CoordinateCoordinate[] Coordinates { get; set; }
    public GeometryType Type { get; set; }
}

public partial class GeoJson
{
    public double[] Bbox { get; set; }
    public CoordinateCoordinate[] Coordinates { get; set; }
    public GeoJsonPointType Type { get; set; }
    public GeoJsonPointGeometry[] Geometries { get; set; }
}

public partial class GeoJsonPointGeometry
{
    public double[] Bbox { get; set; }
    public CoordinateCoordinate[] Coordinates { get; set; }
    public GeometryType Type { get; set; }
}

public enum FeatureType { Feature };

public enum GeometryType { LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon };

public enum GeoJsonPointType { GeometryCollection, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon };

public enum CoordinateType { FeatureCollection };

public partial struct PurpleCoordinate
{
    public double? Double;
    public double[] DoubleArray;

    public static implicit operator PurpleCoordinate(double Double) => new PurpleCoordinate { Double = Double };
    public static implicit operator PurpleCoordinate(double[] DoubleArray) => new PurpleCoordinate { DoubleArray = DoubleArray };
}

public partial struct FluffyCoordinate
{
    public PurpleCoordinate[] AnythingArray;
    public double? Double;

    public static implicit operator FluffyCoordinate(PurpleCoordinate[] AnythingArray) => new FluffyCoordinate { AnythingArray = AnythingArray };
    public static implicit operator FluffyCoordinate(double Double) => new FluffyCoordinate { Double = Double };
}

public partial struct CoordinateCoordinate
{
    public FluffyCoordinate[] AnythingArray;
    public double? Double;

    public static implicit operator CoordinateCoordinate(FluffyCoordinate[] AnythingArray) => new CoordinateCoordinate { AnythingArray = AnythingArray };
    public static implicit operator CoordinateCoordinate(double Double) => new CoordinateCoordinate { Double = Double };
}

public partial struct Id
{
    public double? Double;
    public string String;

    public static implicit operator Id(double Double) => new Id { Double = Double };
    public static implicit operator Id(string String) => new Id { String = String };
}
